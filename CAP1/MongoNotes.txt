
What is NoSQL?
NoSQL databases are highly scalable and flexible database management systems which allow you to store and process unstructured as well as semi-structured data which is not possible through RDBMS tools.
NoSQL (Not only SQL) came as a solution to this problem of relational database management systems and allowed the companies to store massive amounts of structured, semi-structured and unstructured data in real-time. It does not certainly imply that it restricts the usage of SQL for these databases.

What was the problem earlier and how NoSQL is resolving it?
Criteria 		Relational Database Management 	NoSQL Database Management
Data model 	Tables and schemas 		Partition Keys to retrieve data
ACID properties 	Strictly followed 			No strict adherence
Scalability 	Vertical scalability 			Horizontal scalability
Data manipulation 	Using queries in SQL and executed by RDBMS 	Using object-based APIs
Velocity of data 	Moderate 			Very high
Suitability 	Structured data 			Structured, semi-structured and unstructured data

NoSQL means “Not only SQL.” These databases are non-relational and distributed.
NoSQL databases are document-oriented. 
 This way, non-structured data (such as articles, photos, social media data, videos, for example, an entire blog post) can be stored in a single document that can be easily found but isn’t necessarily categorized into a bunch of pre-set fields. It’s more intuitive, but note that storing data in bulk like this requires extra processing effort and more storage than the highly organized SQL data. 

Today most of the world famous firms like Google, Facebook, Amazon, etc., are using NoSQL to provide cloud-based services in real-time


    NoSQL is agile because it does not create schemas nor it statically defines the data models
    Instead of tables it uses objects, collections and nested collections
    Deployed over multiple cheap Intel-based servers
    Immediate failover with the help of uni-directional and bi-directional replication of data
    Equipped with the big data, cloud, mobile and web technologies
    Trades conventional ACID properties to incorporate more flexibility and agility.

Why choose NoSQL database
consider the use of NoSQL databases.

    To improve programmer productivity by using a database that better matches an application's needs.
    To improve data access performance via some combination of handling larger data volumes, reducing latency, and improving throughput.

NoSQL does not have a prescriptive definition but we can make a set of common observations, such as:

    Not using the relational model
    Running well on clusters
    Mostly open-source
    Built for the 21st century web estates
    Schema-less

Some of the popular document databases we have seen are MongoDB, CouchDB , Terrastore, OrientDB, RavenDB


SQL vs NoSQL Terminology
SQL			MongoDB 		DynamoDB 		Cassandra 	Couchbase
Table 			Collection 		Table 			Table 		Data Bucket
Row 			Document		Item 			Row 		Document
Column			Field 			Attribute 			Column 		Field
Primary Key		ObjectId			Primary Key 		Primary Key 	Document ID
Index 			Index 			Secondary Index 		Index		Index
View 			View 			Global Secondary Index 	Materialized View 	View
Nested Table or Object	Embedded Document 	Map 			Map 		Map
Array			Array 			List 			List 		List

Documents are the main concept in document databases. The database stores and retrieves documents, which can be XML, JSON, BSON, and so on. These documents are self-describing, hierarchical tree data structures which can consist of maps, collections, and scalar values. The documents stored are similar to each other but do not have to be exactly the same. Document databases store documents in the value part of the key-value store; think about document databases as key-value stores where the value is examinable. Document databases such as MongoDB provide a rich query language and constructs such as database, indexes etc allowing for easier transition from relational databases.

Ways to deploy NoSQL databases

It can be deployed in four different manners :
Types of NoSQL Databases
There are four general types of NoSQL databases, each with their own specific attributes:

Columnar Databases – Reads and writes columns of data rather than the rows. Each column is comparable to a container in RDBMS where a Key defines a row and single row has multiple columns. (also known as wide-column stores) instead of storing data in rows, these databases are designed for storing data tables as sections of columns of data, rather than as rows of data. While this simple description sounds like the inverse of a standard database, wide-column stores offer very high performance and a highly scalable architecture. Examples include: HBase, BigTable and HyperTable.


Document Databases – These databases store and retrieve semi-structured data in the format of documents such as XML, JSON, etc. Some of the popular document databases like MongoDB provide a rich query language for ease of access and smooth transition of data models.
Expands on the basic idea of key-value stores where “documents” contain more complex in that they contain data and each document is assigned a unique key, which is used to retrieve the document. These are designed for storing, retrieving, and managing document-oriented information, also known as semi-structured data. Examples include: MongoDB and CouchDB.

Graph Databases – Stores data as entities and relations between them allowing faster traversal and joining operations to be performed. However these graphs can be built using SQL as well as NoSQL databases. Based on graph theory, these databases are designed for data whose relations are well represented as a graph and has elements which are interconnected, with an undetermined number of relations between them. Examples include: Neo4j and Titan.


In-Memory Key-Value Stores- Suitable for read-heavy workloads and compute-intensive workloads, these databases store critical data in memory which in turn improves the performance of the systems.

Key-Value store – we start with this type of database because these are some of the least complex NoSQL options. These databases are designed for storing data in a schema-less way. In a key-value store, all of the data within consists of an indexed key and a value, hence the name. Examples of this type of database include:Cassandra, DyanmoDB, Azure Table Storage (ATS), Riak, BerkeleyDB.

The following table lays out some of the key attributes that should be considered when evaluating NoSQL databases.
Datamodel 	Performance 	Scalability 	Flexibility 		Complexity 	Functionality
Key-value store 	High 		High 		High 		None 		Variable (None)
Column Store 	High 		High 		Moderate 	Low 		Minimal
Document Store 	High 		Variable (High) 	High 		Low 		Variable (Low)
Graph Database 	Variable 		Variable 		High 		High 		Graph Theory

 the first reasons to use NoSQL is because you have a Big Data project to tackle
    High data velocity – lots of data coming in very quickly, possibly from different locations.
    Data variety – storage of data that is structured, semi-structured and unstructured.
    Data volume – data that involves many terabytes or petabytes in size.
    Data complexity – data that is stored and managed in different locations or data centers.


Key considerations when choosing your NoSQL platform include:

Workload diversity – Big Data comes in all shapes, colors and sizes. Rigid schemas have no place here; instead you need a more flexible design. You want your technology to fit your data, not the other way around. And you want to be able to do more with all of that data – perform transactions in real-time, run  analytics just as fast and find anything you want in an instant from oceans of data, no matter what from that data may take.

Scalability – With big data you want to be able to scale very rapidly and elastically, whenever and wherever you want. This applies to all situations, whether  scaling across multiple data centers and even to the cloud if needed.

Performance – As has already been discussed, in an online world where nanosecond delays can cost you sales, Big Data must move at extremely high velocities no matter how much you scale or what workloads your database must perform. Performance of your environment, namely your applications, should be high on the list of requirements for deploying a NoSQL platform.

Continuous Availability – Building off of the performance consideration, when you rely on big data to feed your essential, revenue-generating 24/7 business applications, even high availability is not high enough. Your data can never go down, therefore there should be no single point of failure in your NoSQL environment, thus ensuring applications are always available.

Manageability – Operational complexity of a NoSQL platform should be kept at a minimum. Make sure that the administration and development required to both maintain and maximize the benefits of moving to a NoSQL environment are achievable.

Cost – This is certainly a glaring reason for making the move to a NoSQL platform as meeting even one of the considerations presented here with relational database technology can cost become prohibitively expensive. Deploying NoSQL properly allows for all of the benefits above while also lowering operational costs.


Strong Community – This is perhaps one of the more important factors to keep in mind as you move to a NoSQL platform. Make sure there is a solid and capable community around the technology, as this will provide an invaluable resource for the individuals and teams that will be managing the environment. Involvement on the part of the vendor should not only include strong support and technical resource availability, but also consistent outreach to the user base. Good local user groups and meetups will provide many opportunities for communicating with other individuals and teams that will provide great insight into how to work best with the platform of choice.

Benefits of NoSQL
NoSQL databases offer enterprises important advantages over traditional RDBMS, including:

    Scalability: NoSQL databases use a horizontal scale-out methodology that makes it easy to add or reduce capacity quickly and non-disruptively with commodity hardware. This eliminates the tremendous cost and complexity of manual sharding that is necessary when attempting to scale RDBMS.

    Performance: By simply adding commodity resources, enterprises can increase performance with NoSQL databases. This enables organizations to continue to deliver reliably fast user experiences with a predictable return on investment for adding resources—again, without the overhead associated with manual sharding.

    High Availability: NoSQL databases are generally designed to ensure high availability and avoid the complexity that comes with a typical RDBMS architecture that relies on primary and secondary nodes. Some “distributed” NoSQL databases use a masterless architecture that automatically distributes data equally among multiple resources so that the application remains available for both read and write operations even when one node fails.

    Global Availability: By automatically replicating data across multiple servers, data centers, or cloud resources, distributed NoSQL databases can minimize latency and ensure a consistent application experience wherever users are located. An added benefit is a significantly reduced database management burden from manual RDBMS configuration, freeing operations teams to focus on other business priorities.

    Flexible Data Modeling: NoSQL offers the ability to implement flexible and fluid data models. Application developers can leverage the data types and query options that are the most natural fit to the specific application use case rather than those that fit the database schema. The result is a simpler interaction between the application and the database and faster, more agile development.


Reasons to use a SQL database


You need to ensure ACID compliancy (Atomicity, Consistency, Isolation, Durability). ACID compliancy reduces anomalies and protects the integrity of your database by prescribing exactly how transactions interact with the database. Generally, NoSQL databases sacrifice ACID compliancy for flexibility and processing speed, but for many e-commerce and financial applications, an ACID-compliant database remains the preferred option.

Your data is structured and unchanging. If your business is not experiencing massive growth that would require more servers and you’re only working with data that’s consistent, then there may be no reason to use a system designed to support a variety of data types and high traffic volume.

Reasons to use a NoSQL database
When all of the other components of your server-side application are designed to be fast and seamless, NoSQL databases prevent data from being the bottleneck. Big data is the real NoSQL motivator here, doing things that traditional relational databases cannot. It’s driving the popularity of NoSQL databases like MongoDB, CouchDB, Cassandra, and HBase.

Storing large volumes of data that often have little to no structure. A NoSQL database sets no limits on the types of data you can store together, and allows you to add different new types as your needs change. With document-based databases, you can store data in one place without having to define what “types” of data those are in advance.
    
Making the most of cloud computing and storage. Cloud-based storage is an excellent cost-saving solution, but requires data to be easily spread across multiple servers to scale up. Using commodity (affordable, smaller) hardware on-site or in the cloud saves you the hassle of additional software, and NoSQL databases like Cassandra are designed to be scaled across multiple data centers out of the box without a lot of headaches.

Rapid development. If you’re developing within two-week Agile sprints, cranking out quick iterations, or needing to make frequent updates to the data structure without a lot of downtime between versions, a relational database will slow you down. NoSQL data doesn’t need to be prepped ahead of time.


MongoDB is a cross-platform, document oriented database that provides, high performance, high availability, and easy scalability. MongoDB works on concept of collection and document.
MongoDB is no sql database


Advantages of MongoDB over RDBMS
*  Schema less: MongoDB is a document database in which one collection holds different documents. Number of fields, content and size of the document can differ from one document to another.
*  Structure of a single object is clear.
*  No complex joins.
*  Deep query-ability. MongoDB supports dynamic queries on documents using a document-based query language that's nearly as powerful as SQL.
*  Tuning.
*  Ease of scale-out: MongoDB is easy to scale.
*  Conversion/mapping of application objects to database objects not needed.
*  Uses internal memory for storing the (windowed) working set, enabling faster access of data.

Database
Database is a physical container for collections. Each database gets its own set of files on the file system. A single MongoDB server typically has multiple databases.

Collection
Collection is a group of MongoDB documents. It is the equivalent of an RDBMS table. A collection exists within a single database. Collections do not enforce a schema. Documents within a collection can have different fields. Typically, all documents in a collection are of similar or related purpose.

Document
A document is a set of key-value pairs. Documents have dynamic schema. Dynamic schema means that documents in the same collection do not need to have the same set of fields or structure, and common fields in a collection's documents may hold different types of data.

The following table shows the relationship of RDBMS terminology with MongoDB.

RDBMS 						MongoDB
Database						Database
Table						Collection
Tuple/Row					Document
column						Field
Table Join					Embedded Documents
Primary Key					Primary Key (Default key _id provided by mongodb itself)
		Database Server and Client				
Mysqld/Oracle				mongod						mysql/sqlplus				mongo

Why Use MongoDB?
*  Document Oriented Storage: Data is stored in the form of JSON style documents.
*  Index on any attribute
*  Replication and high availability
*  Auto-sharding
*  Rich queries
*  Fast in-place updates
*  Professional support by MongoDB


Where to Use MongoDB?
*  Big Data
*  Content Management and Delivery
*  Mobile and Social Infrastructure
*  User Data Management
*  Data Hub

Install MongoDB on Windows
c:\> wmic os get caption
c:\> wmic os get osarchitecture

server start
C:\Users\admin>cd C:\Program Files\MongoDB\Server\3.4\bin\
C:\Users\admin>mongod.exe

Client start
C:\Users\admin>mongo

>db.test.save( { a: 1 } )

>db.test.find()

>db.help()

>db.stats()

>use DATABASE_NAME 			----is used to create database.

>use mydb

To check your currently selected database, use the command db
>db

check your databases list
>show dbs

Your created database (mydb) is not present in list. To display database, you need to insert at least one document into it.
>use mydb
>db.movie.insert({'name':'tutorials point'})
>show dbs

In MongoDB default database is test

This will delete the selected database. If you have not selected any database, then it will delete default 'test' database.
db.dropDatabase()

Collection ----- Table
db.createCollection(name, options)
Parameter 			Type 		Description
Name				String		Name of the collection to be created
Options				Document	(Optional) Specify options about memory size and indexing

Options parameter is optional, so you need to specify only the name of the collection. Following is the list of options you can use:
Field			Type 			Description
capped			Boolean		(Optional) If true, enables a capped collection. 
					Capped collection is a fixed size collection that automatically overwrites 						its oldest entries when it reaches its maximum size. If you specify true, 						you need to specify size parameter also.
autoIndexID		Boolean		(Optional) If true, automatically create index on _id field. Default value is 						false.
size			number		(Optional) Specifies a maximum size in bytes for a capped collection. If 					capped is true, then you need to specify this field also.
max			number		(Optional) Specifies the maximum number of documents allowed in the 					capped collection.

>db.createCollection('mycollection')

>db.createCollection('mycol', { capped : true, size : 6142800, max : 10000 } )

>show collections

MongoDB's db.collection.drop() is used to drop a collection from the database.
db.COLLECTION_NAME.drop()
>db.mycol.drop()

To insert data into MongoDB collection, you need to use MongoDB's insert() or save()method.
DOCUMENT ----- ROW
>db.COLLECTION_NAME.insert(document)

>db.mycol.insert({
title: 'MongoDB Overview',
description: 'MongoDB is no sql database',
by: 'tutorials point',
url: 'http://www.tutorialspoint.com',
tags: ['mongodb', 'database', 'NoSQL'],
likes: 100
})

To insert multiple documents in a single query
>db.mycol.insert([
{
title: 'MongoDB Overview-1',
description: 'MongoDB is no sql database',
by: 'tutorials point',
url: 'http://www.tutorialspoint.com',
tags: ['mongodb', 'database', 'NoSQL'],
likes: 100
},
{
title: 'MongoDB Overview-2',
description: 'MongoDB is no sql database',
by: 'tutorials point',
url: 'http://www.tutorialspoint.com',
tags: ['mongodb', 'database', 'NoSQL'],
likes: 100
},
{
title: 'MongoDB Overview-1',
description: 'MongoDB is no sql database',
by: 'tutorials point',
url: 'http://www.tutorialspoint.com',
tags: ['mongodb', 'database', 'NoSQL'],
likes: 100
}])

The find() Method
To query data from MongoDB collection, you need to use MongoDB's find()method
>db.COLLECTION_NAME.find()
>db.mycol.find()

The pretty() Method
To display the results in a formatted way, you can use pretty() method.
>db.mycol.find().pretty()

RDBMS Where Clause Equivalents in MongoDB
To query the document on the basis of some condition, you can use following operations
Operation		Syntax			Example					RDBMS Equivalent
Equality		{<key>:<value>}		db.mycol.find({'by':'tutorials point'}).pretty()	where by = 'tutorials point'
Less Than	{<key>:{$lt:<value>}}	db.mycol.find({'likes':{$lt:50}}).pretty()		where likes < 50
Less Than Equals	{<key>:{$lte:<value>}}	db.mycol.find({'likes':{$lte:50}}).pretty()		where likes <= 50
Greater Than	{<key>:{$gt:<value>}}	db.mycol.find({'likes':{$gt:50}}).pretty()		where likes > 50
Greater Than Equals{<key>:{$gte:<value>}}	db.mycol.find({'likes':{$gte:50}}).pretty()		where likes >= 50
Not Equals	{<key>:{$ne:<value>}}	db.mycol.find({'likes':{$ne:50}}).pretty()		where likes != 50


AND in MongoDB
Syntax
>db.mycol.find({key1:value1, key2:value2}).pretty()

>db.mycol.find({'by':'tutorials point','title': 'MongoDB Overview'}).pretty()

OR in MongoDB
To query documents based on the OR condition, you need to use $or keyword
Syntax
>db.mycol.find(
{
$or: [
{key1: value1}, {key2:value2}
]
}
).pretty()

>db.mycol.find({$or:[{'by':'tutorials point'},{'title': 'MongoDB Overview'}]}).pretty()

Using AND and OR Together
>db.mycol.find({'likes': {$gt:10}, $or: [{'by': 'tutorials point'},{'title': 'MongoDB Overview'}]}).pretty()

MongoDB Update() Method
MongoDB's update() and save() methods are used to update document into a collection. The update() method updates the values in the existing document while the save() method replaces the existing document with the document passed in save() method.

Syntax
>db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA)

>db.mycol.update({'title':'MongoDB Overview'},{$set:{'title':'MongoDB Tutorial'}})
>db.mycol.find()

By default, MongoDB will update only a single document. To update multiple documents, you need to set a parameter 'multi' to true.

>db.mycol.update({'title':'MongoDB Tutorial'}, {$set:{'title':'MongoDB Tutorial'}},{multi:true})

MongoDB Save() Method
The save() method replaces the existing document with the new document passed in the save() method.
*Syntax
The basic syntax of MongoDB save() method is 
>db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})

>db.mycol.save(
{
'_id' : ObjectId('5a1d01770bb7a58139d5a1e5'), 'title':'MongoDB Overview-5',
'by':'Tutorials Point'
}
)

The remove() Method
MongoDB's remove() method is used to remove a document from the collection. remove() method accepts two parameters. One is deletion criteria and second is justOne flag.
* deletion criteria: (Optional) deletion criteria according to documents will be removed.
* justOne: (Optional) if set to true or 1, then remove only one document.
Syntax
Basic syntax of remove() method is as follows:
>db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)

>db.mycol.remove({'title':'MongoDB Overview'})

>db.mycol.remove({'title':'MongoDB Overview'})

Remove Only One
>db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)

Remove All Documents		This is equivalent of SQL's truncate command
>db.mycol.remove()
>db.mycol.find()

find() method, then it displays all fields of a document. To limit this, you need to set a list of fields with value 1 or 0. 1 is used to show the field while 0 is used to hide the fields.
>db.mycol.find({},{"title":1,_id:0})

The Limit() Method
To limit the records in MongoDB, you need to use limit() method
The basic syntax of limit() method is as follows:
>db.COLLECTION_NAME.find().limit(NUMBER)

>db.mycol.find({},{"title":1,_id:0}).limit(2)

MongoDB Skip() Method
skip() which also accepts number type argument and is used to skip the number of documents.
Syntax
The basic syntax of skip() method is as follows:
>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)

>db.mycol.find({},{"title":1,_id:0}).limit(1).skip(1)

The sort() Method
The method accepts a document containing a list of fields along with their sorting order. To specify sorting order 1 and -1 are used. 1 is used for ascending order while -1 is used for descending order.
Syntax
The basic syntax of sort() method is as follows:
>db.COLLECTION_NAME.find().sort({KEY:1})

>db.mycol.find({},{"title":1,_id:0}).sort({"title":-1})

Indexes support the efficient resolution of queries. Without indexes, MongoDB must scan every document of a collection to select those documents that match the query statement. This scan is highly inefficient and require MongoDB to process a large volume of data.

The ensureIndex() Method
To create an index you need to use ensureIndex() method of MongoDB.
Syntax
The basic syntax of ensureIndex() method is as follows().
>db.COLLECTION_NAME.ensureIndex({KEY:1})

Here key is the name of the file on which you want to create index and 1 is for ascending order. To create index in descending order you need to use -1.

>db.mycol.ensureIndex({"title":1})

ensureIndex() method you can pass multiple fields, to create index on multiple fields.

>db.mycol.ensureIndex({"title":1,"description":-1})

Aggregations operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result.

db.mycollection.insert([
{
title: 'MongoDB Overview',
description: 'MongoDB is no sql database',
by_user: 'tutorials point',
url: 'http://www.tutorialspoint.com',
tags: ['mongodb', 'database', 'NoSQL'],
likes: 100
},
{
title: 'NoSQL Overview',
description: 'No sql database is very fast',
by_user: 'tutorials point',
url: 'http://www.tutorialspoint.com',
tags: ['mongodb', 'database', 'NoSQL'],
likes: 10
},
{
title: 'Neo4j Overview',
description: 'Neo4j is no sql database',
by_user: 'Neo4j',
url: 'http://www.neo4j.com',
tags: ['neo4j', 'database', 'NoSQL'],
likes: 750
}])

The aggregate() Method
For the aggregation in MongoDB, you should use aggregate() method.
Syntax
Basic syntax of aggregate() method is as follows:
>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)

Sql equivalent query for the above use case will be select by_user, count(*) from mycol group by by_user.
> db.mycollection.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : 1}}}])

Expression	Description 								Example
$sum		Sums up the defined value from all documents in the collection.			db.mycollection.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : "$likes"}}}])
$avg		Calculates the average of all given values from all documents in the collection.		db.mycollection.aggregate([{$group : {_id : "$by_user", num_tutorial : {$avg : "$likes"}}}])
$min		Gets the minimum of the corresponding values from all documents in the collection.	db.mycollection.aggregate([{$group : {_id : "$by_user", num_tutorial : {$min : "$likes"}}}])
$max		Gets the maximum of the corresponding values from all documents in the collection.	db.mycollection.aggregate([{$group : {_id : "$by_user", num_tutorial : {$max : "$likes"}}}])
$push		Inserts the value to an array in the resulting document.				db.mycollection.aggregate([{$group : {_id : "$by_user", url : {$push: "$url"}}}])
$addToSet	Inserts the value to an array in the resulting document but does not create duplicates.	db.mycollection.aggregate([{$group : {_id : "$by_user", url : {$addToSet : "$url"}}}])
$first		Gets the first document from the source documents according to the grouping. Typically this makes only sense together with some previously applied  “$sort”-stage.	db.mycollection.aggregate([{$group : {_id : "$by_user", first_url : {$first : "$url"}}}])
$last		Gets the last document from the source documents according to the grouping. Typically this makes only sense together with some previously applied “$sort”-stage.	db.mycollection.aggregate([{$group : {_id : "$by_user", last_url : {$last : "$url"}}}])

Pipeline Concept
In UNIX command, shell pipeline means the possibility to execute an operation on some input and use the output as the input for the next command and so on. MongoDB also supports same concept in aggregation framework. There is a set of possible stages and each of those is taken as a set of documents as an input and produces a resulting set of documents (or the final resulting JSON document at the end of the pipeline). This can then in turn be used for the next stage and so on.
Following are the possible stages in aggregation framework:
* $project: Used to select some specific fields from a collection.
* $match: This is a filtering operation and thus this can reduce the amount of documents that are given as input to the next stage.
* $group: This does the actual aggregation as discussed above.
* $sort: Sorts the documents.
* $skip: With this, it is possible to skip forward in the list of documents for a given amount of documents.
* $limit: This limits the amount of documents to look at, by the given number starting from the current positions.
* $unwind: This is used to unwind document that are using arrays. When using an array, the data is kind of pre-joined and this operation will be undone with this to have individual documents again. Thus with this stage we will increase the amount of documents for the next stage.

MongoDB - Replication
Replication is the process of synchronizing data across multiple servers. Replication provides redundancy and increases data availability with multiple copies of data on different database servers. Replication protects a database from the loss of a single server. Replication also allows you to recover from hardware failure and service interruptions. With additional copies of the data, you can dedicate one to disaster recovery, reporting, or backup.
Why Replication?
* To keep your data safe
* High (24*7) availability of data
* Disaster recovery
* No downtime for maintenance (like backups, index rebuilds, compaction)
* Read scaling (extra copies to read from)
* Replica set is transparent to the application

How Replication Works in MongoDB
MongoDB achieves replication by the use of replica set. A replica set is a group of mongod instances that host the same data set. In a replica, one node is primary node that receives all write operations. All other instances, such as secondaries, apply operations from the primary so that they have the same data set. Replica set can have only one primary node.
* Replica set is a group of two or more nodes (generally minimum 3 nodes are required).
* In a replica set, one node is primary node and remaining nodes are secondary.
* All data replicates from primary to secondary node.
* At the time of automatic failover or maintenance, election establishes for primary and a new primary node is elected.
* After the recovery of failed node, it again joins the replica set and works as a secondary node.

Replica Set Features
* A cluster of N nodes
* Any one node can be primary
* All write operations go to primary
* Automatic failover
* Automatic recovery
* Consensus election of primary

To convert to replica set, following are the steps:
* Shutdown already running MongoDB server.
* Start the MongoDB server by specifying -- replSet option. Following is the basic syntax of --replSet:

Syntax
mongod --port "PORT" --dbpath "YOUR_DB_DATA_PATH" --replSet "REPLICA_SET_INSTANCE_NAME"

c:/>mongod --port 27017 --dbpath c:\data --replSet rs0

Add Members to Replica Set
Syntax
The basic syntax of rs.add() command is as follows:
>rs.add(HOST_NAME:PORT)
>rs.add("admin-PC:27017")

To check whether you are connected to primary or not, issue the command db.isMaster() in Mongo client.

MongoDB - Sharding
43
Sharding is the process of storing data records across multiple machines and it is MongoDB's approach to meeting the demands of data growth. As the size of the data increases, a single machine may not be sufficient to store the data nor provide an acceptable read and write throughput. Sharding solves the problem with horizontal scaling. With sharding, you add more machines to support data growth and the demands of read and write operations.
Why Sharding?
* In replication, all writes go to master node
* Latency sensitive queries still go to master
* Single replica set has limitation of 12 nodes
* Memory can't be large enough when active dataset is big
* Local disk is not big enough
* Vertical scaling is too expensive

Shards: Shards are used to store data.
Config Servers: Config servers store the cluster's metadata.
Query Routers: Query routers are basically mongo instances, interface with client applications and direct operations to the appropriate shard.

MongoDB - Create Backup
Dump MongoDB Data
To create backup of database in MongoDB, you should use mongodumpcommand. This command will dump the entire data of your server into the dump directory. There are many options available by which you can limit the amount of data or create backup of your remote server.
Syntax
The basic syntax of mongodump command is as follows:
C:\Users\admin>mongodump

Restore Data
To restore backup data MongoDB's mongorestore command is used. This command restores all of the data from the backup directory.
Syntax
The basic syntax of mongorestore command is:
C:\Users\admin>mongorestore


mongostat
This command checks the status of all running mongod instances and return counters of database operations. These counters include inserts, queries, updates, deletes, and cursors. Command also shows when you’re hitting page faults, and showcase your lock percentage. This means that you're running low on memory, hitting write capacity or have some performance issue.
C:\Users\admin>mongostat

mongotop
This command tracks and reports the read and write activity of MongoDB instance on a collection basis. By default, mongotop returns information in each second, which you can change it accordingly. You should check that this read and write activity matches your application intention, and you’re not firing too many writes to the database at a time, reading too frequently from a disk, or are exceeding your working set size.
C:\Users\admin>mongotop
C:\Users\admin>mongotop 30
will return values every 30 seconds.


MongoDB - Relationships
Relationships in MongoDB represent how various documents are logically related to each other. Relationships can be modeled via Embedded and Referenced approaches. Such relationships can be either 1:1, 1:N, N:1 or N:N.

case of storing addresses for users. So, one user can have multiple addresses making this a 1:N relationship

db.createCollection('details')
document structure of user document -
db.details.insert({
"_id":ObjectId("52ffc33cd85242f436000001"),
"name": "Tom Hanks",
"contact": "987654321",
"dob": "01-01-1991"
})

document structure of address document
db.details.insert({
"_id":ObjectId("52ffc4a5d85242602e000000"),
"building": "22 A, Indiana Apt",
"pincode": 123456,
"city": "Los Angeles",
"state": "California"
})

Modeling Embedded Relationships
db.createCollection('users')
db.users.insert({
"_id":ObjectId("52ffc33cd85242f436000001"),
"contact": "987654321",
"dob": "01-01-1991",
"name": "Tom Benzamin",
"address": [
{
"building": "22 A, Indiana Apt",
"pincode": 123456,
"city": "Los Angeles",
"state": "California"
},
{
"building": "170 A, Acropolis Apt",
"pincode": 456789,
"city": "Chicago",
"state": "Illinois"
}]})

>db.users.findOne({"name":"Tom Benzamin"},{"address":1})


Modeling Referenced Relationships
This is the approach of designing normalized relationship. In this approach, both the user and address documents will be maintained separately but the user document will contain a field that will reference the address document's id field.

{
"_id":ObjectId("52ffc33cd85242f436000001"),
"contact": "987654321",
"dob": "01-01-1991",
"name": "Tom Benzamin",
"address_ids": [
ObjectId("52ffc4a5d85242602e000000"),
ObjectId("52ffc4a5d85242602e000001")
]}

>var result = db.users.findOne({"name":"Tom Benzamin"},{"address_ids":1})
>var addresses = db.address.find({"_id":{"$in":result["address_ids"]}})

MongoDB - Database References
the concept of Referenced Relationships also referred to as Manual References in which we manually store the referenced document's id inside other document. However, in cases where a document contains references from different collections, we can use MongoDB DBRefs.

DBRefs vs Manual References
when a user collection's document references an address, it also needs to specify which collection to look into based on the address type. In such scenarios where a document references documents from many collections, we should use DBRefs.

Using DBRefs
There are three fields in DBRefs:
* $ref: This field specifies the collection of the referenced document
* $id: This field specifies the _id field of the referenced document
* $db: This is an optional field and contains the name of the database in which the referenced document lies

db.details.insert({
"_id":ObjectId("53402597d852426020000002"),
"address": {
"$ref": "address_home",
"$id": ObjectId("534009e4d852427820000002"),
"$db": "tutorialspoint"},
"contact": "987654321",
"dob": "01-01-1991",
"name": "Tom Benzamin"
})

>var user = db.details.findOne({"name":"Tom Benzamin"})
>var dbRef = user.address
>db[dbRef.$ref].findOne({"_id":(dbRef.$id)})

MongoDB - Covered Queries
As per the official MongoDB documentation, a covered query is a query in which:
* All the fields in the query are part of an index.
* All the fields returned in the query are in the same index.
Since all the fields present in the query are part of an index, MongoDB matches the query conditions and returns the result using the same index without actually looking inside the documents. Since indexes are present in RAM, fetching data from indexes is much faster as compared to fetching data by scanning documents.

Using Covered Queries
db.details.insert({
"_id": ObjectId("53402597d852426020000002"),
"contact": "987654321",
"dob": "01-01-1991",
"gender": "M",
"name": "Tom Benzamin",
"user_name": "tombenzamin"
})

We will first create a compound index for the users collection on the fields gender and user_name using the following query:
>db.users.ensureIndex({gender:1,user_name:1}) 

Now, this index will cover the following query:
>db.users.find({gender:"M"},{user_name:1,_id:0})

>db.users.find({gender:"M"},{user_name:1})


MongoDB - Analyzing Queries
Analyzing queries is a very important aspect of measuring how effective the database and indexing design is. We will learn about the frequently used $explain and $hint queries.
Using $explain
The $explain operator provides information on the query, indexes used in a query and other statistics. It is very useful when analyzing how well your indexes are optimized

>db.users.ensureIndex({gender:1,user_name:1})

>db.users.find({gender:"M"},{user_name:1,_id:0}).explain()

We will now look at the fields in this result set:
* The true value of indexOnly indicates that this query has used indexing.
* The cursor field specifies the type of cursor used. BTreeCursor type indicates that an index was used and also gives the name of the index used. BasicCursor indicates that a full scan was made without using any indexes.
* n indicates the number of documents matching returned.
* nscannedObjects indicates the total number of documents scanned.
* nscanned indicates the total number of documents or index entries scanned.

Using $hint
The $hint operator forces the query optimizer to use the specified index to run a query. This is particularly useful when you want to test performance of a query with different indexes. For example, the following query specifies the index on fields gender and user_name to be used for this query:
>db.users.find({gender:"M"},{user_name:1,_id:0}).hint({gender:1,user_name:1}) 
To analyze the above query using $explain:
>db.users.find({gender:"M"},{user_name:1,_id:0}).hint({gender:1,user_name:1}).explain()

MongoDB - Atomic Operations
MongoDB does not support multi-document atomic transactions. However, it does provide atomic operations on a single document. So if a document has hundred fields the update statement will either update all the fields or none, hence maintaining atomicity at the document-level.

atomic.
Consider the following products document:
db.createCollection('products')
db.products.insert({
"_id":1,
"product_name": "Samsung S3",
"category": "mobiles",
"product_total": 5,
"product_available": 3,
"product_bought_by": [
{
"customer": "john",
"date": "7-Jan-2014"
},
{
"customer": "mark",
"date": "8-Jan-2014"
} ] } )



>db.products.findAndModify({
query:{_id:2,product_available:{$gt:0}},
update:{
$inc:{product_available:-1},
$push:{product_bought_by:{customer:"rob",date:"9-Jan-2014"}}
} } )

********
types of data you can add to a document, and what you use them for:
• String: 		This commonly used datatype contains a string of text (or any other kind of characters). This datatype is used mostly for storing text values (for example, 'Country' : 'Japan'}.
• Integer (32b and 64b): 	This type is used to store a numerical value (for example, { 'Rank' : 1 } ). Note that there are no quotes placed before or after the integer.
• Boolean: 	This datatype can be set to either TRUE or FALSE.
• Double: 		This datatype is used to store floating-point values.
• Min / Max keys: 	This datatype is used to compare a value against the lowest and highest BSON elements, respectively.
• Arrays: 		This datatype is used to store arrays (for example,['Membrey, Peter','Plugge, Eelco','Hows, David']).
• Timestamp: 	This datatype is used to store a timestamp. This can be handy for recording when a document has been modified or added.
• Object: 		This datatype is used for embedded documents.
• Null: 		This datatype is used for a Null value.
• Symbol: 		This datatype is used identically to a string; however, it’s generally reserved for languages that use a specific symbol type.
• Date *: 		This datatype is used to store the current date or time in Unix time format (POSIX time).
• Object ID *: 	This datatype is used to store the document’s ID.
• Binary data *: 	This datatype is used to store binary data.
• Regular expression *: This datatype is used for regular expressions. All options are represented by specific characters provided in alphabetical order. You will learn more about regular expressions
• JavaScript Code *: This datatype is used for JavaScript code.

The asterisks mean that the last five datatypes (date, object ID, binary data, regex, and JavaScript code) are non-JSON types; specifically, they are special datatypes that BSON allows you to use.




Basic Commands within the MongoDB Shell
Command 		Function
show dbs 		Shows the names of the available databases.
show collections 		Shows the collections in the current database.
show users 		Shows the users in the current database.
use <db name> 		Sets the current database to <db name>.

> help
        db.help()                    help on db methods
        db.mycoll.help()         help on collection methods
        sh.help()                    sharding helpers
        rs.help()                    replica set helpers
        help admin                administrative help
        help connect             connecting to a db help
        help keys                  key shortcuts
        help misc                  misc things to know
        help mr                     mapreduce
        show dbs                 show database names
        show collections      show collections in current database
        show users              show users in current database
        show profile             show most recent system.profile entries with time >= 1ms
        show logs                show the accessible logger names
        show log [name]      prints out the last segment of log in memory, 'global' is default
        use <db_name>      set current database
        db.foo.find()            list objects in collection foo
        db.foo.find( { a : 1 } )     list objects in foo where a == 1
        it                           result of the last line evaluated; use to further iterate
        DBQuery.shellBatchSize = x   set default number of items to display on shell
        exit                         quit the mongo shell
>














The Included MongoDB Applications

Application 			Function
-- bsondump 			Reads contents of BSON-formatted rollback files.
-- mongo 				The database shell.
-- mongod			The core database server.
-- mongodump 			Database backup utility.
-- mongoexport 			Export utility (JSON, CSV, TSV), not reliable for backup.
-- mongofiles 			Manipulates files in GridFS objects.
-- mongoimport 			Import utility (JSON, CSV, TSV), not reliable for recoveries.
-- mongooplog 			Pulls oplog entries from another mongod instance.
-- mongoperf 			Check disk I/O performance.
--mongorestore 			Database backup restore utility.
--mongos 			Mongodb sharding routerprocess.
--mongosniff 			Sniff/traces MongoDB database activity in real time, Unix-like
systems only.
--mongostat 			Returns counters of database operation.
--mongotop 			Tracks/reports MongoDB read/write activities.
-- mongorestore 			Restore/import utility.